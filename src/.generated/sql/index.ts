// Generated by @prisma-sql/generator - DO NOT EDIT
import { buildSQL, transformQueryResults, type PrismaMethod, type Model } from 'prisma-sql'

export const MODELS: Model[] = [
  {
    "name": "Country",
    "tableName": "countries",
    "fields": [
      {
        "name": "countryCode",
        "dbName": "country_code",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "currencyCode",
        "dbName": "currency_code",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "countryNameEn",
        "dbName": "country_name_en",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "countryNameLocal",
        "dbName": "country_name_local",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "currencyNameEn",
        "dbName": "currency_name_en",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "tinType",
        "dbName": "tin_type",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "tinName",
        "dbName": "tin_name",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "officialLanguageCode",
        "dbName": "official_language_code",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "officialLanguageNameEn",
        "dbName": "official_language_name_en",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "officialLanguageNameLocal",
        "dbName": "official_language_name_local",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "countryCallingCode",
        "dbName": "country_calling_code",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "region",
        "dbName": "region",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "flag",
        "dbName": "flag",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "users",
        "dbName": "users",
        "type": "User[]",
        "isRequired": true,
        "isRelation": true,
        "relatedModel": "User",
        "foreignKey": "countryCode",
        "references": "countryCode",
        "relationName": "CountryToUser",
        "isForeignKeyLocal": false
      }
    ]
  },
  {
    "name": "User",
    "tableName": "users",
    "fields": [
      {
        "name": "id",
        "dbName": "id",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "isDeleted",
        "dbName": "is_deleted",
        "type": "Boolean",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "isChatBlocked",
        "dbName": "is_chat_blocked",
        "type": "Boolean",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "createdAt",
        "dbName": "created_at",
        "type": "DateTime",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "updatedAt",
        "dbName": "updated_at",
        "type": "DateTime",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "chatReadAt",
        "dbName": "chat_read_at",
        "type": "DateTime",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "username",
        "dbName": "username",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "avatarUrl",
        "dbName": "avatar_url",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "about",
        "dbName": "about",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "email",
        "dbName": "email",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "emailVerified",
        "dbName": "email_verified",
        "type": "Boolean",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "policyAgreed",
        "dbName": "policy_aggreed",
        "type": "Boolean",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "multiAccountsDetected",
        "dbName": "multi_accounts_detected",
        "type": "Boolean",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "password",
        "dbName": "password",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "telegram",
        "dbName": "telegram",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "kickUrl",
        "dbName": "kick_url",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "youtubeUrl",
        "dbName": "youtube_url",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "discordId",
        "dbName": "discord_id",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "discordRefreshToken",
        "dbName": "discord_refresh_token",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "kickId",
        "dbName": "kick_id",
        "type": "Int",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "kickSlug",
        "dbName": "kick_slug",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "kickAccessToken",
        "dbName": "kick_access_token",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "kickRefreshToken",
        "dbName": "kick_refresh_token",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "razedId",
        "dbName": "razed_id",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "razedAccessToken",
        "dbName": "razed_access_token",
        "type": "String",
        "isRequired": false,
        "isRelation": false
      },
      {
        "name": "countryCode",
        "dbName": "country_code",
        "type": "String",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "country",
        "dbName": "country",
        "type": "Country",
        "isRequired": true,
        "isRelation": true,
        "relatedModel": "Country",
        "foreignKey": "countryCode",
        "references": "countryCode",
        "relationName": "CountryToUser",
        "isForeignKeyLocal": true
      },
      {
        "name": "flag",
        "dbName": "flag",
        "type": "UserFlag",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "permissions",
        "dbName": "permissions",
        "type": "UserPermission[]",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "balance",
        "dbName": "balance",
        "type": "Int",
        "isRequired": true,
        "isRelation": false
      },
      {
        "name": "experiencePoints",
        "dbName": "experience_points",
        "type": "Int",
        "isRequired": true,
        "isRelation": false
      }
    ]
  }
]

const QUERIES: Record<string, Record<string, Record<string, {
  sql: string
  params: unknown[]
  dynamicKeys: string[]
  paramMappings: any[]
}>>> = {}

const DIALECT = "postgres"

function isDynamicParam(key: string): boolean {
  return key === 'skip' || key === 'take' || key === 'cursor'
}

function normalizeQuery(args: any): string {
  if (!args) return '{}'
  
  const normalized = JSON.parse(JSON.stringify(args))
  
  function replaceDynamicParams(obj: any): any {
    if (!obj || typeof obj !== 'object') return obj
    
    if (Array.isArray(obj)) {
      return obj.map(replaceDynamicParams)
    }
    
    const result: any = {}
    for (const [key, value] of Object.entries(obj)) {
      if (isDynamicParam(key)) {
        result[key] = `__DYNAMIC_${key}__`
      } else {
        result[key] = replaceDynamicParams(value)
      }
    }
    return result
  }
  
  const withMarkers = replaceDynamicParams(normalized)
  
  function removeEmptyObjects(obj: any): any {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return obj
    
    const result: any = {}
    for (const [key, value] of Object.entries(obj)) {
      if (value && typeof value === 'object' && !Array.isArray(value) && Object.keys(value).length === 0) {
        continue
      }
      result[key] = removeEmptyObjects(value)
    }
    return result
  }
  
  const cleaned = removeEmptyObjects(withMarkers)
  
  return JSON.stringify(cleaned, (key, value) => {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      const sorted: Record<string, unknown> = {}
      for (const k of Object.keys(value).sort()) {
        sorted[k] = value[k]
      }
      return sorted
    }
    return value
  })
}

function extractDynamicParams(args: any, dynamicKeys: string[]): unknown[] {
  const params: unknown[] = []
  
  for (const key of dynamicKeys) {
    const parts = key.split(':')
    const lookupKey = parts.length === 2 ? parts[1] : key
    const value = args[lookupKey]
    
    if (value === undefined) {
      throw new Error(`Missing required parameter: ${key}`)
    }
    
    params.push(value)
  }
  
  return params
}

async function executeQuery(client: any, sql: string, params: unknown[]): Promise<unknown[]> {
  if (DIALECT === 'postgres') {
    return await client.unsafe(sql, params)
  }
  
  const stmt = client.prepare(sql)
  
  if (sql.toUpperCase().includes('COUNT(*) AS')) {
    return [stmt.get(...params)]
  }
  
  return stmt.all(...params)
}

export function speedExtension(config: {
  postgres?: any
  sqlite?: any
  debug?: boolean
  onQuery?: (info: {
    model: string
    method: string
    sql: string
    params: unknown[]
    duration: number
    prebaked: boolean
  }) => void
}) {
  const { postgres, sqlite, debug, onQuery } = config

  if (!postgres && !sqlite) {
    throw new Error('speedExtension requires postgres or sqlite client')
  }

  const client = postgres || sqlite
  const actualDialect = postgres ? 'postgres' : 'sqlite'

  if (actualDialect !== DIALECT) {
    throw new Error(`Generated code is for ${DIALECT}, but you provided ${actualDialect}`)
  }

  return (prisma: any) => {
    const handleMethod = async function(this: any, method: PrismaMethod, args: any) {
      const modelName = this?.name || this?.$name
      const startTime = Date.now()

      const queryKey = normalizeQuery(args)
      const prebakedQuery = QUERIES[modelName]?.[method]?.[queryKey]

      let sql: string
      let params: unknown[]
      let prebaked = false

      if (prebakedQuery) {
        sql = prebakedQuery.sql
        params = [...prebakedQuery.params, ...extractDynamicParams(args, prebakedQuery.dynamicKeys)]
        prebaked = true
      } else {
        const model = MODELS.find((m) => m.name === modelName)
        
        if (!model) {
          return this.$parent[modelName][method](args)
        }

        const result = buildSQL(model, MODELS, method, args || {}, DIALECT)
        sql = result.sql
        params = result.params
      }

      if (debug) {
        console.log(`[${DIALECT}] ${modelName}.${method} ${prebaked ? 'âš¡ PREBAKED' : 'ðŸ”¨ RUNTIME'}`)
        console.log('SQL:', sql)
        console.log('Params:', params)
      }

      const results = await executeQuery(client, sql, params)
      const duration = Date.now() - startTime

      onQuery?.({
        model: modelName,
        method,
        sql,
        params,
        duration,
        prebaked,
      })

      return transformQueryResults(method, results)
    }

    return prisma.$extends({
      name: 'prisma-sql-generated',
      
      client: {
        $original: prisma,
      },

      model: {
        $allModels: {
          async findMany(args: any) {
            return handleMethod.call(this, 'findMany', args)
          },
          async findFirst(args: any) {
            return handleMethod.call(this, 'findFirst', args)
          },
          async findUnique(args: any) {
            return handleMethod.call(this, 'findUnique', args)
          },
          async count(args: any) {
            return handleMethod.call(this, 'count', args)
          },
          async aggregate(args: any) {
            return handleMethod.call(this, 'aggregate', args)
          },
          async groupBy(args: any) {
            return handleMethod.call(this, 'groupBy', args)
          },
        },
      },
    })
  }
}
